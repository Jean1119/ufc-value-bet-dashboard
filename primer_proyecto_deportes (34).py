# -*- coding: utf-8 -*-
"""primer_proyecto_deportes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12WRb6NZQkSIhEATar2c2wey0OyUfbX3u
"""

import os
import streamlit as st
import pandas as pd
import numpy as np
import requests
import joblib
from datetime import datetime, timedelta
from sklearn.preprocessing import LabelEncoder

# ── Page config ─────────────────────────────────────────────────────────────
st.set_page_config(page_title="UFC Value Bet Dashboard", layout="wide")

# ── Helpers ─────────────────────────────────────────────────────────────────
@st.cache_data
def load_history() -> pd.DataFrame:
    """Load UFC history CSV (large_dataset.csv or ufc_master.csv) and merge fighter stats."""
    # Choose history file
    if os.path.exists('large_dataset.csv'):
        history_path = 'large_dataset.csv'
    elif os.path.exists('ufc_master.csv'):
        history_path = 'ufc_master.csv'
    else:
        raise FileNotFoundError("No UFC history CSV found (large_dataset.csv or ufc_master.csv)")
    df = pd.read_csv(history_path)
    # Merge fighter stats if available
    stats_path = 'fighter_stats.csv'
    if os.path.exists(stats_path):
        df_stats = pd.read_csv(stats_path)
        red_stats = df_stats.add_prefix('Red_')
        df = df.merge(red_stats, left_on='RedFighter', right_on='Red_Name', how='left')
        blue_stats = df_stats.add_prefix('Blue_')
        df = df.merge(blue_stats, left_on='BlueFighter', right_on='Blue_Name', how='left')
        # Compute stat differences for numeric stats
        stat_cols = [c for c in df_stats.columns if c != 'Name']
        for stat in stat_cols:
            df[f'{stat}Dif'] = df[f'Red_{stat}'] - df[f'Blue_{stat}']
    return df

@st.cache_resource
def load_model_and_features():
    """Load pretrained model and feature list."""
    model = joblib.load('ufc_model.pkl')
    # Core features + any computed *Dif columns
    base_feats = [
        'RedOdds','BlueOdds','RedExpectedValue','BlueExpectedValue',
        'WinStreakDif','LossDif','KODif','SubDif',
        'HeightDif','ReachDif','AgeDif'
    ]
    df = load_history()
    dif_feats = [c for c in df.columns if c.endswith('Dif') and c not in base_feats]
    features = base_feats + dif_feats
    return model, features

@st.cache_data
def fetch_live_odds(api_key: str) -> list:
    """Fetch moneyline odds from the Odds API."""
    url = 'https://api.the-odds-api.com/v4/sports/mma_mixed_martial_arts/odds'
    params = {
        'apiKey': api_key,
        'regions': 'us',
        'markets': 'h2h',
        'oddsFormat': 'american'
    }
    r = requests.get(url, params=params)
    r.raise_for_status()
    return r.json()

def implied_prob(o: float) -> float:
    """Convert American odds to implied probability."""
    return 100.0/(o+100.0) if o > 0 else abs(o)/(abs(o)+100.0)

# ── Main ────────────────────────────────────────────────────────────────────
def main():
    # Sidebar inputs
    st.sidebar.header("Settings")
    api_key = st.sidebar.text_input("Odds API Key", type="password")
    edge_threshold = st.sidebar.slider("Edge Threshold (pp)", 0, 100, 15)
    days_ahead = st.sidebar.slider("Show events in next N days", 1, 30, 7)
    filter_str = st.sidebar.text_input("Filter matchups (comma-separated)")

    if not api_key:
        st.warning("Enter your Odds API key in the sidebar to continue.")
        return

    # Build filter terms list
    filter_terms = [t.strip().lower() for t in filter_str.split(",") if t.strip()]

    st.title("UFC Value Bet Dashboard")

    # 1) Load history
    with st.spinner("Loading UFC history…"):
        df_hist = load_history()

    # 2) Load model
    with st.spinner("Loading model…"):
        model, features = load_model_and_features()

    # Historical preview
    st.subheader("Historical Data Preview")
    st.dataframe(df_hist.head(5))

    # 3) Fetch live odds
    with st.spinner("Fetching live odds…"):
        events = fetch_live_odds(api_key)

    # Build odds table
    now = datetime.utcnow()
    cutoff = now + timedelta(days=days_ahead)
    odds_rows = []
    for ev in events:
        for bm in ev.get('bookmakers', []):
            markets = bm.get('markets', [])
            if not markets:
                continue
            mkt = markets[0]
            outcomes = mkt.get('outcomes', [])
            if len(outcomes) != 2:
                continue
            try:
                fight_time = datetime.fromisoformat(ev['commence_time'].replace('Z',''))
            except:
                continue
            if not (now <= fight_time <= cutoff):
                continue
            f1, f2 = outcomes[0]['name'], outcomes[1]['name']
            event_name = f"{f1} vs {f2}"
            if filter_terms and not any(t in event_name.lower() for t in filter_terms):
                continue
            odds_rows.append({
                'Event': event_name,
                'Time (UTC)': ev['commence_time'],
                f1: outcomes[0]['price'],
                f2: outcomes[1]['price'],
            })
    df_odds = pd.DataFrame(odds_rows)

    st.subheader("Live Odds")
    if df_odds.empty:
        st.info("No upcoming fights match your criteria.")
        return
    st.dataframe(df_odds)

    # 4) Compute value bets
    st.subheader(f"Value Bets (Edge ≥ {edge_threshold} pp)")
    with st.spinner("Computing value bets…"):
        value_bets = []
        for _, row in df_odds.iterrows():
            fighters = [c for c in row.index if c not in ['Event','Time (UTC)']]
            if len(fighters) != 2:
                continue
            f1, f2 = fighters
            o1, o2 = row[f1], row[f2]
            # match in history
            mask = (
                (df_hist['RedFighter']==f1) & (df_hist['BlueFighter']==f2)
            ) | (
                (df_hist['RedFighter']==f2) & (df_hist['BlueFighter']==f1)
            )
            hist = df_hist[mask]
            if hist.empty:
                continue
            idx = hist.index[0]
            probs = model.predict_proba(hist.loc[[idx], features])[0]
            for fighter, odds, side in [(f1,o1,'Red'),(f2,o2,'Blue')]:
                ip = implied_prob(odds)
                p  = probs[1] if side=='Red' else probs[0]
                edge = (p - ip) * 100
                if edge >= edge_threshold:
                    value_bets.append({
                        'Event': row['Event'],
                        'Fighter': fighter,
                        'Side': side,
                        'Odds': odds,
                        'Edge (pp)': round(edge,1)
                    })
    if value_bets:
        df_vb = pd.DataFrame(value_bets).sort_values('Edge (pp)', ascending=False)
        st.table(df_vb)
    else:
        st.info("No value bets meet your threshold.")

    # 5) Staking simulation
    st.subheader("Staking Strategy Simulation")
    with st.spinner("Running staking simulation…"):
        BASE_EDGE, SAFE_EDGE = 5, 10
        BASE_STAKE, SAFE_STAKE = 0.02, 0.15
        bankroll = 10_000.0
        balances = []
        for vb in value_bets:
            frac = SAFE_STAKE if vb['Edge (pp)'] >= SAFE_EDGE else BASE_STAKE
            stake = bankroll * frac
            payout = stake * (vb['Odds']/100) if vb['Odds']>0 else stake * (100/abs(vb['Odds']))
            won = (
                ((df_hist['RedFighter']==vb['Fighter']) & (vb['Side']=='Red') & (df_hist['Winner']=='Red')) |
                ((df_hist['BlueFighter']==vb['Fighter']) & (vb['Side']=='Blue') & (df_hist['Winner']=='Blue'))
            ).any()
            profit = payout if won else -stake
            bankroll += profit
            balances.append(bankroll)
    if balances:
        st.line_chart(pd.DataFrame({'Bankroll': balances}, index=range(1,len(balances)+1)))

    st.write(f"**Initial Bankroll:** $10,000")
    st.write(f"**Final Bankroll:** ${bankroll:,.2f}")
    st.write(f"**ROI:** {((bankroll-10_000)/10_000*100):.1f}%")

if __name__ == '__main__':
    main()